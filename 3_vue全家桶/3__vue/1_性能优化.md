# 1.提升vue性能的方法

## 1.路由懒加载
使用路由懒加载，项目打包的体积会大幅度减小，访问项目时，组件也会按需加载，大大提升项目性能

```
Vue.use(vueRouter)

// 传统写法
import Home from '@/views/home/index.vue'

// 路由懒加载
const Login = () => import('@/views/login/login.vue')

export const router = new vueRouter({
    routes: [
        {
            path: '/login',
            component: Login,
        },
        {
            path: '/home',
            component: Home,
        }
    ]
})

```

## 2.keep-alive缓存页面

使用keep-alive之后页面会缓存，第一次加载之后，关闭再打开，页面不会重新渲染

keep-alive属性：
- include: 字符串或正则表达式，如果只缓存个别页面，可以使用此属性，只会缓存匹配组件
- exclude: 字符串或正则表达式，如果个别页面不需要缓存，可以使用此属性，匹配的组件都不会缓存

作用： 
- 保留组件状态
- 避免重新渲染

```
<template>
    <keep-alive>
       <router-view />
    </keep-alive>
</template>
```


## 3.v-for遍历避免同时使用v-if
v-for优先级较高，会先执行v-for,每次遍历都会执行v-if解析，浪费性能

## 4.长列表性能优化
如果是单纯的数据展示，不会有任何数据的改变，不需要做响应式

```
export default {
    data() {
        return {
            list: []
        }
    },
    methods: {
        getData() {
            const data = await axios('/list');
            this.list = Object.freeeze(data)
        }
    }
}
```

Object.freeeze()可以冻结一个对象，对象被冻结以后不能修改，可以让性能提升

如果是大数据长列表，可以采用虚拟滚动，只渲染少部门区域的内容，可以采用第三方vue-virtual-scroll

## 5)事件的销毁

vue组件销毁时，会自动解绑它的全部指令和时间监听器，但是仅限于组件本身的事件

## 6）图片懒加载

# 2.vue如何实现按需加载配合webpack

webpack中提供了require.ensure()来实现按需加载

以前引入路由是通过import方式,改为const引入

```
页面正常引入：
import Home form '...home'

按需加载
const home = r => require.ensure([], () => r(require('../home.vue')))
```
 # 3.v-if和v-show区别

v-show:（频繁显示隐藏，节省性能）
- 修改元素的display的css属性让元素隐藏、显示

v-if
- 是直接销毁、重建dom


# 4.常用生命周期钩子函数

1）created
实例创建完成之后调用，在这一步，已经完后才能数据观测，属性方法的运算，watch和evebt事件回调
但是$el属性目前不可见，挂载阶段还没开始

2）mounted
el被新创建的vm.$el替换，并挂载到实例上去之后调用该函数。
如果root上挂载一个文档元素，当mounted被调用时，vm.$el也在文档内

3）activated
keep-alive 组件被激活时调用