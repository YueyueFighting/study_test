<!DOCTYPE html>
<html>

<head>
    <title>1_promiseAll实现</title>
    <meta charset="utf-8">
</head>

<body>
    <h1>
        1_promiseAll实现
    </h1>
    <script>

        // promise.all()返回值是new Promise
        // 需要用一个数组存放每一个promise的结果值
        // 遍历参数数组，判断是否是promise，是的话执行得到结果后压入结果数组；否则直接放入结果数组。
        // 当每个都成功执行后，resolve（result）
        // 当有一个失败，reject

        function p1() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('p1')
                }, 500)
            })
        }
        function p2() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('p2')
                }, 600)
            })
        }
        function p3() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('p3')
                }, 700)
            })
        }
        function p4() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('p4')
                }, 800)
            })
        }

        let p5 = 1337;

        // 检查是否是promise
        function isPromise(obj) {
            return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
        }

        // 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。
        // 为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型
        // 具有iterable类型的集合可以通过新的for ... of循环来遍历
        function all(iterable) {
            let resultArray = [];
            return new Promise((resolve, reject) => {
                let isReturn = false;
                iterable.forEach((promise, index) => {
                    if (isPromise(promise)) {
                        promise.then((result) => {
                            resultArray[index] = result
                            // 全部成功才返回结果
                            if (resultArray.length == iterable.length) {
                                resolve(resultArray)
                            }
                        }, (fail) => {
                            reject(fail)
                        })
                    } else {
                        resultArray[index] = iterable[index];
                    }
                })
            })
        }
        all([p1(), p2(), p3(), p4(), p5])
            .then((result) => {
                //                 0: "p1"
                // 1: "p2"
                // 2: "p3"
                // 3: "p4"
                // 4: 1337
                console.log('===============函数调用---result=================== ', result);
            }, (err) => {
                console.log('================函数调用---err=================== ', err);
            })

        const promisesArray = [
            new Promise((resolve, reject) =>
                setTimeout(() => resolve('result----A'), 2000)), // (A)

            new Promise((resolve, reject) =>
                setTimeout(() => resolve('result-----B'), 2100)), // (B)

            new Promise((resolve, reject) =>
                setTimeout(() => resolve('result------C'), 2200)), // (C)

            new Promise((resolve, reject) =>
                setTimeout(() => resolve('result------D'), 2300)), // (C)
        ]

        all(promisesArray)
            .then((result) => {
                console.log('================直接定义--result=================== ', result);
            }, (err) => {
                console.log('================直接定义--err=================== ', err);
            })
    </script>
</body>

</html>